---
title: "R Notebook"
output: html_notebook
---

```{r}
library(tidyverse)
library(ggpubr)
library(effectsize)
load('../Pre-procesamiento/dataset_final.rda')
```

Creamos el nuevo dataset para este analisis eliminando aquellos usuarios que no reportaron horas reales de uso de instagram.

```{r}
h2_dataset <- final_dataset %>%
  drop_na(uso_screnshot)
```

Posteriormente calculamos si la categoria que asignaron segun su autopercepcion coincide con las horas reales de uso de instagram. Para eso utilizamos una lookup table.

```{r}
lookup_table <- data.frame(
  categoria = c('Más de 3 hs por día', '2-3 hs por día', '1-2 hs por día', '31-60 min por día', '10-30 min por día', 'Menos de 10 min por día'),
  uper_bound = c(Inf, 10800, 7200, 3600, 1800, 600),
  lower_bound = c(10800, 7200, 3600, 1860, 600, -Inf)
)


sesgo_estimacion_fun <- function(cat_value, num_value){
  acierto <- ifelse(
    between(num_value, lookup_table[lookup_table$categoria == cat_value, 3], lookup_table[lookup_table$categoria == cat_value, 2]), 'ok', F
    )
  if(acierto == F){
    if(
      num_value > lookup_table[lookup_table$categoria == cat_value, 2] #Si el valor esta por encima del umbral superior
    ){
      return('sub')
    }else{
      return('sobre')
    }
  }else{
    return(acierto)
  }
}
```

Utilizando los objetos creados anteriormente calculamos para cada sujeto si subestimo, sobreestimo o tuvo una estimacion correcta.

```{r}
h2_dataset <- h2_dataset %>% 
  rowwise() %>%
  mutate(
  sesgo = sesgo_estimacion_fun(selfperception_cat, uso_screnshot)
  )
```

Para responder a la segunda hipotesis vemos los puntajes en la escala de FOMO para los distintos tipos de respuesta.

```{r}
violin_fomo_sesgo_plot_all <- h2_dataset %>%
  ggplot(aes(x = sesgo, y = fomo_puntaje, fill = sesgo)) +
  geom_violin(alpha = 0.75, trim = F) +
  stat_summary(fun.data = mean_se, fun.args = list('mult' = 2)) +
  stat_summary(fun.data = mean_se, fun.args = list('mult' = 2), geom = 'errorbar', width = 0.1) +
  ylab('FOMO') + xlab('Tipo de respuesta') +
  scale_fill_discrete('Tipo de respuesta', labels = c('Correcta', 'Sobreestimacion', 'Subestimacion')) +
  scale_x_discrete(
    labels=c("ok" = "Correcta", "sobre" = "Sobreestimacion",
                              "sub" = "Subestimacion"),
    limits = c('sub', 'ok', 'sobre')
  ) +
  theme_classic()
violin_fomo_sesgo_plot_all
```

Repetimos el mismo grafico pero esta vez excluimos aquellos sujetos cuya respuesta categorica no es consistente con su respuesta numerica.

```{r}
violin_fomo_sesgo_plot_self <- h2_dataset %>% filter(error_selfperception == FALSE) %>%
  ggplot(aes(x = sesgo, y = fomo_puntaje, fill = sesgo)) +
  geom_violin(alpha = 0.75, trim = F) +
  stat_summary(fun.data = mean_se, fun.args = list('mult' = 2)) +
  stat_summary(fun.data = mean_se, fun.args = list('mult' = 2), geom = 'errorbar', width = 0.1) +
  ylab('FOMO') + xlab('Tipo de respuesta') +
  scale_fill_discrete('Tipo de respuesta', labels = c('Correcta', 'Sobreestimacion', 'Subestimacion')) +
  scale_x_discrete(
    labels=c("ok" = "Correcta", "sobre" = "Sobreestimacion",
                              "sub" = "Subestimacion"),
    limits = c('sub', 'ok', 'sobre')
  ) +
  theme_classic()
violin_fomo_sesgo_plot_self
```

De nuevo repetimos el mismo grafico pero excluyendo a todos los sujetos, quienes respondieron incosistentemente a cualquiera de las dos categorias

```{r}
violin_fomo_sesgo_plot_none <- h2_dataset %>% 
  filter(error_selfperception == FALSE & error_otherperception == FALSE) %>%
  ggplot(aes(x = sesgo, y = fomo_puntaje, fill = sesgo)) +
  geom_violin(alpha = 0.75, trim = F) +
  stat_summary(fun.data = mean_se, fun.args = list('mult' = 2)) +
  stat_summary(fun.data = mean_se, fun.args = list('mult' = 2), geom = 'errorbar', width = 0.1) +
  ylab('FOMO') + xlab('Tipo de respuesta') +
  scale_fill_discrete('Tipo de respuesta', labels = c('Correcta', 'Sobreestimacion', 'Subestimacion')) +
  scale_x_discrete(
    labels=c("ok" = "Correcta", "sobre" = "Sobreestimacion",
                              "sub" = "Subestimacion"),
    limits = c('sub', 'ok', 'sobre')
  ) +
  theme_classic()
violin_fomo_sesgo_plot_none
```
Combinamos todos los graficos en uno solo

```{r}
ggarrange(
  violin_fomo_sesgo_plot_all, violin_fomo_sesgo_plot_self, violin_fomo_sesgo_plot_none,
  labels = c('A', 'B', 'C'),
  ncol = 1, nrow = 3
)
ggsave('test.png',
       width = 15, height = 25, units = "cm")
```

Para hacer las comparaciones generamos un codigo que nos permita realizar permutaciones. La funcion toma simplemente un vector con dos categorias y un vector numerico con la variable de respuesta de interes. 

```{r}
permutaciones_mean <- function(categoria, respuesta){
  shuffle_categoria <- sample(categoria, length(categoria))
  
  shuffle_df <- tibble(
    shuf_cat = shuffle_categoria,
    resp = respuesta
  )
  
  shuffle_df %>%
  group_by(shuf_cat) %>% summarise(x = mean(resp)) %>% summarise(x = diff(x)) %>% pull(x)
}
```

Siendo que vamos a usar esto varias veces lo empaquetamos en una funcion. La funcion toma como argumentos un dataframe, una string con el nombre de la columna con la categoria (binaria) y una string con el nombre de la variable de respuesta que nos interesa. Devuelve como resultado un vector de permutaciones.

```{r}
comparacion_permutaciones_fn <- function(dataset, nombre_categoria, nombre_respuesta){
  res_perm <- replicate(
  10000,
  permutaciones_mean(
    dataset[[nombre_categoria]],
    dataset[[nombre_respuesta]]
    )
  )
  return(res_perm)
}
```

Lo aplicamos primero comparando con la categoria de estimacion correcta para todos los sujetos usando 10 mil permutaciones.

```{r}
permutacion_ok <- comparacion_permutaciones_fn(h2_dataset %>% filter(sesgo != 'sobre'), 'sesgo', 'fomo_puntaje')
```

Graficamos el histograma de la distribucion de diferencias bajo la hipotesis nula.

```{r}
perm_plot_ok_all <- ggplot() +
  geom_histogram(
    aes(x = permutacion_ok),
    fill = 'white',
    color = 'black'
  ) +
  geom_vline(
    xintercept = mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'ok']) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub']),
    size = 1, linetype = 'dashed'
      ) +
  theme_classic() +
  xlab("Diferencia de medias") + ylab('Frecuencia')
perm_plot_ok_all
```

La diferencia de medias en la escala de FOMO entre aquellos que realizaron una estimacion correcta y aquellos que tuvieron un sesgo de subestimacion no es significativamente distinta de la esperada bajo un modelo nulo. 

```{r}
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'ok'])
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub'])
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'ok']) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub'])
quantile(permutacion_ok, c(0.025,0.975))
```

Replicamos el procedimiento anterior excluyendo aquellos sujetos con respuestas incosistentes en la autopercepcion. 

```{r}
permutacion_ok_consistente <- comparacion_permutaciones_fn(
  h2_dataset %>% filter(sesgo != 'sobre' & error_selfperception == FALSE), 
  'sesgo', 'fomo_puntaje'
  )

perm_plot_ok_self <- ggplot() +
  geom_histogram(
    aes(x = permutacion_ok_consistente),
    fill = 'white',
    color = 'black'
  ) +
  geom_vline(
    xintercept = mean(
      h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'ok' & h2_dataset$error_selfperception == F]) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub' & h2_dataset$error_selfperception == F]),
    size = 1, linetype = 'dashed'
      ) +
  theme_classic() +
  xlab("Diferencia de medias") + ylab('Frecuencia')
```

Las diferencias precisas fueron de

```{r}
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'ok' & h2_dataset$error_selfperception == F])
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub' & h2_dataset$error_selfperception == F])
mean(
      h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'ok' & h2_dataset$error_selfperception == F]) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub' & h2_dataset$error_selfperception == F])
quantile(permutacion_ok_consistente, c(0.025,0.975))
```

Por ultimo excluimos a aquellos que tuvieron una inconsistencia en la autoestimacion o la heteroestimacion

```{r}
permutacion_ok_all_consistente <- comparacion_permutaciones_fn(
  h2_dataset %>% filter(sesgo != 'sobre' & error_selfperception == FALSE & error_otherperception == FALSE), 
  'sesgo', 'fomo_puntaje'
  )

perm_plot_ok_none <- ggplot() +
  geom_histogram(
    aes(x = permutacion_ok_all_consistente),
    fill = 'white',
    color = 'black'
  ) +
  geom_vline(
    xintercept = mean(
      h2_dataset %>% filter(sesgo == 'ok' & error_selfperception == FALSE & error_otherperception == FALSE) %>% pull(fomo_puntaje)
      ) - mean(
         h2_dataset %>% filter(sesgo == 'sub' & error_selfperception == FALSE & error_otherperception == FALSE) %>% pull(fomo_puntaje)
                                                                ),
    size = 1, linetype = 'dashed'
      ) +
  theme_classic() +
  xlab("Diferencia de medias") + ylab('Frecuencia')
perm_plot_ok_none
```


Las diferencias precisas fueron de

```{r}
#Mean sobreestimacion
mean(
      h2_dataset %>% filter(sesgo == 'ok' & error_selfperception == FALSE & error_otherperception == FALSE) %>% pull(fomo_puntaje)
      )
mean(
         h2_dataset %>% filter(sesgo == 'sub' & error_selfperception == FALSE & error_otherperception == FALSE) %>% pull(fomo_puntaje)
                                                                )
mean(
      h2_dataset %>% filter(sesgo == 'ok' & error_selfperception == FALSE & error_otherperception == FALSE) %>% pull(fomo_puntaje)
      ) - mean(
         h2_dataset %>% filter(sesgo == 'sub' & error_selfperception == FALSE & error_otherperception == FALSE) %>% pull(fomo_puntaje)
                                                                )

quantile(permutacion_ok_all_consistente, c(0.025,0.975))
```

Unimos todos los graficos en uno solo

```{r}
ggarrange(
  perm_plot_ok_all, perm_plot_ok_self, perm_plot_ok_none,
  labels = c('A', 'B', 'C'),
  ncol = 1, nrow = 3
)
ggsave('test.png',
       height = 13, width = 10, units = 'cm')
```

Ahora repetimos el procedimiento comparando los sujetos que hicieron una subestimacion con aquellos que hicieron una sobreestimacion

```{r}
permutacion_sobre_all <- comparacion_permutaciones_fn(
  h2_dataset %>% filter(sesgo != 'ok'), 
  'sesgo', 'fomo_puntaje'
  )

perm_plot_sobre_all <- ggplot() +
  geom_histogram(
    aes(x = permutacion_sobre_all),
    fill = 'white',
    color = 'black'
  ) +
  geom_vline(
    xintercept = mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sobre']) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub']),
    size = 1, linetype = 'dashed'
      ) +
  theme_classic() +
  xlab("Diferencia de medias") + ylab('Frecuencia')
perm_plot_sobre_all
```

La diferencia pareceria ser significativa, para darnos una idea mas formal calculamos el intervalo del 95% sobre la distribucion de diferencias calculada con permutaciones.

```{r}
#Media de los sujetos que sobreestimaron
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sobre'])
#Media de los sujetos que subestimaron
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub'])
#Diferencia de medias
mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sobre']) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub'])
sum(
  abs(permutacion_sobre_all) >= abs(mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sobre']) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub'])))/10000
quantile(permutacion_sobre_all, c(0.025,0.975))
cohens_d(fomo_puntaje ~ sesgo, data = h2_dataset %>% filter(sesgo != 'ok'), pooled_sd = F)
```

Vemos que la diferencia de `r mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sobre']) - mean(h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub'])` esta por encima de este intervalo lo que seria equivalente a un nivel de significancia de 0.05

Repetimos el procedimiento de permutaciones con excluyendo sujetos igual que se hizo anteriormente

```{r}
permutacion_sobre_consistente <-  comparacion_permutaciones_fn(
  h2_dataset %>% filter(sesgo != 'ok' & error_selfperception == FALSE), 
  'sesgo', 'fomo_puntaje'
  )

permutacion_sobre_all_consistente <-  comparacion_permutaciones_fn(
  h2_dataset %>% filter(sesgo != 'ok' & error_selfperception == FALSE & error_otherperception == FALSE), 
  'sesgo', 'fomo_puntaje'
  )

perm_plot_sobre_self <- ggplot() +
  geom_histogram(
    aes(x = permutacion_sobre_consistente),
    fill = 'white',
    color = 'black'
  ) +
  geom_vline(
    xintercept = mean(
      h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sobre' & h2_dataset$error_selfperception == F]
      ) - mean(
        h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub' & h2_dataset$error_selfperception == F]
        ),
    size = 1, linetype = 'dashed'
      ) +
  theme_classic() +
  xlab("Diferencia de medias") + ylab('Frecuencia')
perm_plot_sobre_self

perm_plot_sobre_none <- ggplot() +
  geom_histogram(
    aes(x = permutacion_sobre_all_consistente),
    fill = 'white',
    color = 'black'
  ) +
  geom_vline(
    xintercept = mean(
      h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sobre' & h2_dataset$error_selfperception == F]
      ) - mean(
        h2_dataset$fomo_puntaje[h2_dataset$sesgo == 'sub' & h2_dataset$error_selfperception == F]
        ),
    size = 1, linetype = 'dashed'
      ) +
  theme_classic() +
  xlab("Diferencia de medias") + ylab('Frecuencia')
perm_plot_sobre_none
```

El resultado es aparente unicamente en el caso con todos los sujetos pero desaparece cuando excluimos a cualquiera de los dos grupos.

Por ultimo realizamos un modelo logistico utilizando la sobreestimacion y la subestimacion como categorias binarias a predecir utilizando los puntajes en la escala de FOMO.

```{r}
glm(
  sesgo ~ fomo_puntaje, family = binomial(link = 'logit'), 
  data = h2_dataset %>% filter(sesgo != 'ok') %>% mutate(sesgo = ifelse(sesgo == 'sub', 1, 0))
) %>% summary()
```

El coeficiente relativo al puntaje en la escala de FOMO es significativo y negativo lo cual significa que un incremente en el puntaje en la escala de FOMO esta asociado a una menor probabilidad de pertenecer al grupo categorizado como 1 que es el grupo de subestimacion, en concordancia con los resultados anteriores. 

Repetimos el modelo con los mismos criterios de exclusion que antes.

```{r}
glm(
  sesgo ~ fomo_puntaje, family = binomial(link = 'logit'), 
  data = h2_dataset %>% filter(sesgo != 'ok' & error_selfperception == F) %>% mutate(sesgo = ifelse(sesgo == 'sub', 1, 0))
) %>% summary()

glm(
  sesgo ~ fomo_puntaje, family = binomial(link = 'logit'), 
  data = h2_dataset %>% filter(sesgo != 'ok' & error_selfperception == F & error_otherperception == F) %>% mutate(sesgo = ifelse(sesgo == 'sub', 1, 0))
) %>% summary()
```

Podemos ahora comparar el desempeño del modelo con todos los sujetos contra un modelo nulo

```{r}
performance::compare_performance(
  glm(
  sesgo ~ 1, family = binomial(link = 'logit'), 
  data = h2_dataset %>% filter(sesgo != 'ok') %>% mutate(sesgo = ifelse(sesgo == 'sub', 1, 0))
  ),
glm(
  sesgo ~ fomo_puntaje, family = binomial(link = 'logit'), 
  data = h2_dataset %>% filter(sesgo != 'ok') %>% mutate(sesgo = ifelse(sesgo == 'sub', 1, 0))
  ) 
)
```
El modelo es marginalmente mejor que un modelo nulo.

En definitiva con toda la evidencia recabada decimos que no hay suficiente evidencia para apoyar una diferencia en los puntajes en la escala de FOMO dado por errores de estimacion en el propio uso a partir de la respuesta categorica. 


```{r}
h2_dataset$selfperception_catnum <- fct_recode(h2_dataset$selfperception_cat,
           '6' = 'Más de 3 hs por día', 
           '5' = '2-3 hs por día', 
            '4' = '1-2 hs por día',
            '3' = '31-60 min por día',
            '2' = '10-30 min por día',
            '1' = 'Menos de 10 min por día')
h2_dataset$otherperception_catnum <- fct_recode(h2_dataset$otherperception_cat,
           '6' = 'Más de 3 hs por día', 
           '5' = '2-3 hs por día', 
            '4' = '1-2 hs por día',
            '3' = '31-60 min por día',
            '2' = '10-30 min por día',
            '1' = 'Menos de 10 min por día')

h2_dataset <- h2_dataset %>% ungroup() %>%
  mutate(
    selfperception_catnum = as.integer(selfperception_catnum),
    otherperception_catnum = as.integer(otherperception_catnum),
    sesgo2 = ifelse(selfperception_catnum == otherperception_catnum, 'same',
                    ifelse(selfperception_catnum > otherperception_catnum, 'over', 'under')
                    )
  )
```


```{r}
h2_dataset %>%
  ggplot(
    aes(x = sesgo2, y = fomo_puntaje)
  ) + 
  geom_violin()
```





```{r}
h2_dataset %>%  %>%
  mutate(
    autopercepcion = selfperception_num - uso_screnshot
  )
```



Ahora que tenemos ese dato podemos repetir algunos analisis y hacer otros nuevos contemplando esto como dato a marcar.

```{r}
ggplot(
  data = h2_dataset,
  aes(x = autopercepcion)
) +
  geom_histogram() +
  facet_wrap(~error_selfperception)
```

Con esta etiqueta logramos desahcernos de casi todos los valores extremos lo cual nos dejo una distribucion mucho mas parecida a una normal. Podemos calcular algunas medidas de resumen unicamente de los sujetos con respuestas acordes. 

```{r}
h2_dataset %>% filter(error_selfperception == FALSE) %>% transmute(x = autopercepcion/60) %>% summary(.x)
```

Ahora podemos correr un bootstrap sencillo para ver la distribucion de la media. 

```{r}
h2_dataset_acorde <- h2_dataset %>% filter(error_selfperception == FALSE)
sample_mean <- function(data, indices){
  boot_data <- data[indices,]
  return(mean(boot_data$autopercepcion/60))
}
boot_media_acorde <- boot(
  h2_dataset_acorde,
  sample_mean,
  10000,
  parallel = 'multicore',
  ncpus = 5
)
plot(boot_media_acorde)
boot.ci(boot_media_acorde)
```




```{r}
sd(h2_dataset$autopercepcion)
sd(h2_dataset_acorde$autopercepcion)
sim_test <- replicate(
  10000,
  mean(
    h2_dataset_acorde$uso_screnshot - (h2_dataset_acorde$uso_screnshot + rnorm(nrow(h2_dataset_acorde), sd = 4000))
    )
  )

```





Para ver la influencia de valores individuales vamos a graficar la diferencia entre la media global (con todos los datos) y la media sin un sujeto en particular segun el indice del sujeto que se extrae.

```{r}
diferencia_media_df <- data.frame(
  media_global = mean(h2_dataset$autopercepcion),
  media_modificada = sapply(
  seq(1, nrow(h2_dataset)),
  function(x) mean(h2_dataset$autopercepcion[-x])
  ),
  indice = seq(1, nrow(h2_dataset))
) %>%
  mutate(diferencia = media_global - media_modificada)

ggplot(
  data = diferencia_media_df,
    aes(x = indice, y = diferencia)
  ) +
  geom_point() +
  geom_hline(yintercept = 0)
```

```{r}
hist(diferencia_media_df$diferencia)
```

Posteriormente vamos a tomar ese mismo dataframe y vamos a ordenarlo segun el nivel de impacto en la media que tiene cada sujeto para ir retirando de manera secuencial y acumulativa por el orden de impacto, calculando a cada paso la nueva media. 

```{r}
indices_acumulados <- diferencia_media_df %>%
  arrange(
    desc(
      abs(diferencia)
         )
    ) %>% 
  pull(indice)

plot(
  x = seq(1:50),
  y = sapply(
  seq(1:50),
  function(x) mean(
    h2_dataset$autopercepcion[-c(indices_acumulados[1:x])]
    )
  ),
  type = 'l'
)
```




```{r}
plot(
  x = seq(max(h2_dataset$autopercepcion), min(h2_dataset$autopercepcion), length.out = 1000),
  y = sapply(
  seq(max(h2_dataset$autopercepcion), min(h2_dataset$autopercepcion), length.out = 1000),
  function(x) mean(h2_dataset %>% filter(autopercepcion < x) %>% pull(autopercepcion))
  ),
  type = 'l'
)
```

Media robusta

```{r}
sapply(
  seq(1,10),
  function(x) dplR::tbrm(h2_dataset$autopercepcion, C = x)
)
WRS2::winmean(h2_dataset$autopercepcion, tr = 0.2)
```



```{r}
plot(
  x = seq(max(h2_dataset$autopercepcion), min(h2_dataset$autopercepcion), length.out = 1000),
  y = sapply(
  seq(max(h2_dataset$autopercepcion), min(h2_dataset$autopercepcion), length.out = 1000),
  function(x) sum(h2_dataset$autopercepcion > x)
       ),
  type = 'l'
)
```

```{r}
ggplot(
  data = h2_dataset,
  aes(x = fomo_puntaje, y = autopercepcion)
) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~error_selfperception)
```

```{r}
ggplot(
  data = h2_dataset,
  aes(x = autopercepcion)
) +
  geom_histogram() +
  facet_wrap(~error_selfperception)
```




```{r}
median(h2_dataset$autopercepcion)

plot(
  x = seq(0.01,0.25, length.out = 1000),
  y = sapply(
  seq(0.01,0.25, length.out = 1000),
  function(x) mean(h2_dataset$autopercepcion, trim = x)
       ),
  type = 'l'
)

```



```{r}
corr_boot <- function(data, indices){
  boot_data <- data[indices,]
  pearson_value <- cor(boot_data$fomo_puntaje, boot_data$autopercepcion)
  spearman_value <- cor(boot_data$fomo_puntaje, boot_data$autopercepcion, method = 'spearman')
  c(pearson_value, spearman_value)
}

boot_test <- boot(
  data = h2_dataset,
  statistic = corr_boot,
  R = 10000, 
  parallel = 'multicore',
  ncpus = 4
)

plot(boot_test, index = 1)
plot(boot_test, index = 2)

boot.ci(boot_test, index = 2)
```

```{r}
samplemean <- function(data, indices) {
  boot_data <- data[indices,]
  return(mean(boot_data$autopercepcion))
}
boot_test <- boot(
  data = h2_dataset,
  statistic = samplemean,
  R = 10000, 
  parallel = 'multicore',
  ncpus = 4
)
boot.ci(boot_test, conf = .99)
plot(boot_test)
```



En primer lugar vemos la frecuencia de cada ocurrencia. 

```{r}
h2_dataset %>% ungroup() %>%
  count(sesgo) %>% 
  mutate(
    freq_r = n/sum(n)
    ) %>%
  ggplot(aes(x = sesgo, y = freq_r)) +
  geom_col(aes(fill = sesgo)) +
  geom_label(aes(label = n)) +
  theme_classic() +
  ylab('Frecuencia relativa') + xlab('Tipo de Estimacion') +
  scale_fill_discrete('Estimacion', labels = c("Correcta", 'Sobreestimacion', 'Subestimacion'))
```
